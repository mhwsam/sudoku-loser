<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Killer Sudoku Solver</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        primary: '#5D5CDE',
                        secondary: '#8584E8',
                        dark: {
                            bg: '#181818',
                            cell: '#242424',
                            text: '#E0E0E0'
                        }
                    }
                }
            }
        }
    </script>
    <style>
        /* Handle dark mode detection */
        @media (prefers-color-scheme: dark) {
            :root {
                color-scheme: dark;
            }
        }
        
        /* Custom cage styling */
        .cage-cell {
            position: relative;
        }
        
        .cage-sum {
            position: absolute;
            top: 2px;
            left: 2px;
            font-size: 10px;
            color: #666;
            z-index: 10;
        }
        
        .dark .cage-sum {
            color: #aaa;
        }
        
        /* Cell borders based on cage membership */
        .sudoku-cell {
            border: 1px solid #ddd;
            transition: all 0.2s ease;
        }
        
        .dark .sudoku-cell {
            border: 1px solid #333;
        }
        
        /* Bold borders for 3x3 grid */
        .sudoku-row:nth-child(3n) .sudoku-cell {
            border-bottom: 2px solid #666;
        }
        
        .sudoku-cell:nth-child(3n) {
            border-right: 2px solid #666;
        }
        
        .dark .sudoku-row:nth-child(3n) .sudoku-cell {
            border-bottom: 2px solid #777;
        }
        
        .dark .sudoku-cell:nth-child(3n) {
            border-right: 2px solid #777;
        }
        
        /* Cage highlighted border color */
        .cage-border-top {
            border-top: 2px solid #5D5CDE !important;
        }
        
        .cage-border-right {
            border-right: 2px solid #5D5CDE !important;
        }
        
        .cage-border-bottom {
            border-bottom: 2px solid #5D5CDE !important;
        }
        
        .cage-border-left {
            border-left: 2px solid #5D5CDE !important;
        }
        
        /* Custom animations */
        @keyframes pulse-bg {
            0% { background-color: rgba(93, 92, 222, 0.1); }
            50% { background-color: rgba(93, 92, 222, 0.3); }
            100% { background-color: rgba(93, 92, 222, 0.1); }
        }
        
        .solving-animation {
            animation: pulse-bg 1.2s infinite;
        }
        
        /* Loading spinner */
        .spinner {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 4px solid rgba(93, 92, 222, 0.1);
            border-left-color: #5D5CDE;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Tooltip */
        .tooltip {
            visibility: hidden;
            position: absolute;
            background-color: rgba(0,0,0,0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            z-index: 100;
            font-size: 14px;
            white-space: nowrap;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .tooltip-container:hover .tooltip {
            visibility: visible;
            opacity: 1;
        }
    </style>
</head>
<body class="bg-white dark:bg-dark-bg text-gray-800 dark:text-dark-text min-h-screen flex flex-col">
    <header class="bg-primary text-white p-4 shadow-md">
        <h1 class="text-2xl font-bold text-center">Killer Sudoku Solver</h1>
    </header>

    <main class="flex-1 container mx-auto p-4 flex flex-col md:flex-row gap-6">
        <div class="w-full md:w-auto">
            <div id="sudoku-container" class="grid grid-cols-9 mx-auto max-w-[500px] mb-6">
                <!-- Grid will be populated by JavaScript -->
            </div>
            
            <div class="mb-4 flex flex-col md:flex-row justify-center space-y-2 md:space-y-0 md:space-x-2">
                <div class="flex justify-center space-x-2">
                    <button id="btn-create-cage" class="bg-primary hover:bg-secondary text-white px-4 py-2 rounded-md shadow transition-colors">
                        Create Cage
                    </button>
                    <button id="btn-reset-cage" class="bg-gray-500 hover:bg-gray-600 text-white px-4 py-2 rounded-md shadow transition-colors">
                        Cancel
                    </button>
                </div>
                <div class="flex justify-center space-x-2">
                    <button id="btn-solve" class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-md shadow transition-colors">
                        Solve
                    </button>
                    <button id="btn-reset" class="bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded-md shadow transition-colors">
                        Reset
                    </button>
                </div>
            </div>
        </div>

        <div class="w-full md:w-80 bg-gray-100 dark:bg-dark-cell p-4 rounded-lg shadow-md self-start">
            <h2 class="text-xl font-bold mb-4 text-primary">Instructions</h2>
            
            <div class="mb-6">
                <h3 class="font-semibold mb-2">Creating Cages:</h3>
                <ol class="list-decimal pl-5 space-y-1 text-sm">
                    <li>Click "Create Cage"</li>
                    <li>Select connected cells for your cage</li>
                    <li>Enter the sum for the cage</li>
                    <li>Click "Confirm" to save the cage</li>
                </ol>
            </div>
            
            <div class="mb-6">
                <h3 class="font-semibold mb-2">Rules:</h3>
                <ul class="list-disc pl-5 space-y-1 text-sm">
                    <li>Standard Sudoku rules apply (1-9 in each row, column, and 3x3 box)</li>
                    <li>Cells within a cage must sum to the cage's value</li>
                    <li>No digit can repeat within a cage</li>
                </ul>
            </div>
            
            <div id="cage-list" class="mb-4">
                <h3 class="font-semibold mb-2">Defined Cages:</h3>
                <div id="cages-container" class="text-sm max-h-[200px] overflow-y-auto">
                    <p class="text-gray-500 dark:text-gray-400 italic">No cages defined yet</p>
                </div>
            </div>
            
            <div id="solver-status" class="text-sm hidden p-2 rounded-md bg-blue-100 dark:bg-blue-900 mb-4"></div>
        </div>
    </main>

    <!-- Modal for entering cage sum -->
    <div id="cage-sum-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white dark:bg-dark-cell rounded-lg p-6 max-w-sm w-full mx-4">
            <h3 class="text-xl font-bold mb-4 text-primary">Enter Cage Sum</h3>
            <p class="mb-4">Enter the sum for the selected cage (cells: <span id="selected-cells-count">0</span>):</p>
            <input type="number" id="cage-sum-input" class="w-full px-4 py-2 border rounded-md mb-4 dark:bg-gray-700 dark:border-gray-600 text-base" min="1">
            <div class="flex justify-end space-x-2">
                <button id="btn-cancel-cage" class="px-4 py-2 bg-gray-300 dark:bg-gray-700 rounded-md hover:bg-gray-400 dark:hover:bg-gray-600 transition-colors">
                    Cancel
                </button>
                <button id="btn-confirm-cage" class="px-4 py-2 bg-primary text-white rounded-md hover:bg-secondary transition-colors">
                    Confirm
                </button>
            </div>
        </div>
    </div>

    <!-- Loading overlay -->
    <div id="loading-overlay" class="fixed inset-0 bg-black bg-opacity-50 flex flex-col items-center justify-center z-50 hidden">
        <div class="spinner mb-4"></div>
        <p class="text-white text-lg font-semibold">Solving puzzle...</p>
        <p id="loading-status" class="text-white text-sm mt-2">Initializing...</p>
    </div>

    <script>
        // Initialize dark mode based on user preference
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });

        // Globals
        let isCreatingCage = false;
        let selectedCells = [];
        let cages = [];
        let grid = Array(9).fill().map(() => Array(9).fill(0));
        
        // Initialize the Sudoku grid
        function initGrid() {
            const container = document.getElementById('sudoku-container');
            container.innerHTML = '';
            
            for (let row = 0; row < 9; row++) {
                const rowDiv = document.createElement('div');
                rowDiv.classList.add('sudoku-row', 'w-full');
                
                for (let col = 0; col < 9; col++) {
                    const cellDiv = document.createElement('div');
                    cellDiv.classList.add(
                        'sudoku-cell', 
                        'cage-cell', 
                        'aspect-square',
                        'flex', 
                        'items-center', 
                        'justify-center',
                        'bg-white', 
                        'dark:bg-dark-cell',
                        'cursor-pointer',
                        'select-none',
                        'transition-all'
                    );
                    cellDiv.dataset.row = row;
                    cellDiv.dataset.col = col;
                    
                    const input = document.createElement('input');
                    input.type = 'tel';
                    input.classList.add(
                        'w-full',
                        'h-full',
                        'text-center',
                        'text-xl',
                        'font-semibold',
                        'bg-transparent',
                        'focus:outline-none',
                        'focus:bg-blue-50',
                        'dark:focus:bg-blue-900/30',
                        'appearance-none'
                    );
                    input.maxLength = 1;
                    input.pattern = '[1-9]';
                    input.addEventListener('input', function(e) {
                        const val = e.target.value;
                        // Allow only digits 1-9
                        if (!/^[1-9]$/.test(val)) {
                            e.target.value = '';
                        }
                        updateGrid();
                    });
                    
                    cellDiv.appendChild(input);
                    cellDiv.addEventListener('click', () => handleCellClick(row, col));
                    
                    rowDiv.appendChild(cellDiv);
                }
                
                container.appendChild(rowDiv);
            }
        }
        
        // Handle cell clicks for cage creation
        function handleCellClick(row, col) {
            if (!isCreatingCage) return;
            
            const cellKey = `${row},${col}`;
            const cellIndex = selectedCells.findIndex(cell => cell === cellKey);
            
            if (cellIndex === -1) {
                // Check if this cell is connected to existing selection
                if (selectedCells.length > 0) {
                    const isConnected = selectedCells.some(cellStr => {
                        const [r, c] = cellStr.split(',').map(Number);
                        return (
                            (Math.abs(r - row) === 1 && c === col) || 
                            (r === row && Math.abs(c - col) === 1)
                        );
                    });
                    
                    if (!isConnected && selectedCells.length > 0) {
                        showToast("Cells must be connected!");
                        return;
                    }
                }
                
                // Cell not selected, add it
                selectedCells.push(cellKey);
                highlightSelectedCell(row, col, true);
            } else {
                // Cell was selected, check if removing breaks connectivity
                if (selectedCells.length > 1) {
                    // Create a temp array without this cell to test connectivity
                    const tempSelected = [...selectedCells];
                    tempSelected.splice(cellIndex, 1);
                    
                    if (!areConnected(tempSelected)) {
                        showToast("Removing this cell would break the cage!");
                        return;
                    }
                }
                
                // Remove cell
                selectedCells.splice(cellIndex, 1);
                highlightSelectedCell(row, col, false);
            }
            
            document.getElementById('selected-cells-count').textContent = selectedCells.length;
            
            // Show cage sum modal if at least one cell is selected
            if (selectedCells.length > 0) {
                document.getElementById('btn-confirm-cage').disabled = false;
            } else {
                document.getElementById('btn-confirm-cage').disabled = true;
            }
        }
        
        // Check if cells form a connected component
        function areConnected(cellsArray) {
            if (cellsArray.length <= 1) return true;
            
            const visited = new Set();
            const [startCell] = cellsArray;
            
            function dfs(cellStr) {
                visited.add(cellStr);
                const [row, col] = cellStr.split(',').map(Number);
                
                // Check all 4 adjacent cells
                const neighbors = [
                    `${row+1},${col}`,
                    `${row-1},${col}`,
                    `${row},${col+1}`,
                    `${row},${col-1}`
                ];
                
                for (const neighbor of neighbors) {
                    if (cellsArray.includes(neighbor) && !visited.has(neighbor)) {
                        dfs(neighbor);
                    }
                }
            }
            
            dfs(startCell);
            return visited.size === cellsArray.length;
        }
        
        // Highlight/unhighlight a cell during cage creation
        function highlightSelectedCell(row, col, highlight) {
            const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            
            if (highlight) {
                cell.classList.add('bg-primary/20');
                cell.classList.remove('bg-white', 'dark:bg-dark-cell');
            } else {
                cell.classList.remove('bg-primary/20');
                cell.classList.add('bg-white', 'dark:bg-dark-cell');
            }
        }
        
        // Create a new cage
        function createCage(sum) {
            if (selectedCells.length === 0) return;
            
            // Ensure no cell is part of another cage
            for (const cellStr of selectedCells) {
                for (const cage of cages) {
                    if (cage.cells.includes(cellStr)) {
                        showToast("One or more cells already belong to another cage");
                        return;
                    }
                }
            }
            
            const cage = {
                id: Date.now(),
                sum: sum,
                cells: [...selectedCells]
            };
            
            cages.push(cage);
            updateCageBorders();
            updateCagesList();
            
            // Clear selection
            selectedCells.forEach(cellStr => {
                const [row, col] = cellStr.split(',').map(Number);
                highlightSelectedCell(row, col, false);
            });
            
            selectedCells = [];
            document.getElementById('cage-sum-modal').classList.add('hidden');
        }
        
        // Update borders of cells based on cage membership
        function updateCageBorders() {
            // First reset all borders to default
            document.querySelectorAll('.sudoku-cell').forEach(cell => {
                cell.classList.remove(
                    'cage-border-top', 
                    'cage-border-right', 
                    'cage-border-bottom', 
                    'cage-border-left'
                );
                
                // Remove any existing cage sum
                const existingSum = cell.querySelector('.cage-sum');
                if (existingSum) {
                    existingSum.remove();
                }
            });
            
            // Then set cage borders and sums
            cages.forEach(cage => {
                const cellObjects = cage.cells.map(cellStr => {
                    const [row, col] = cellStr.split(',').map(Number);
                    return { row, col, cellStr };
                });
                
                cellObjects.forEach(({ row, col, cellStr }) => {
                    const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                    
                    // Check all 4 directions to see if border should be highlighted
                    if (!cage.cells.includes(`${row-1},${col}`)) {
                        cell.classList.add('cage-border-top');
                    }
                    if (!cage.cells.includes(`${row+1},${col}`)) {
                        cell.classList.add('cage-border-bottom');
                    }
                    if (!cage.cells.includes(`${row},${col-1}`)) {
                        cell.classList.add('cage-border-left');
                    }
                    if (!cage.cells.includes(`${row},${col+1}`)) {
                        cell.classList.add('cage-border-right');
                    }
                });
                
                // Add sum to the top-left cell of the cage
                let topLeftCell = cellObjects[0];
                for (const cell of cellObjects) {
                    if (cell.row < topLeftCell.row || 
                        (cell.row === topLeftCell.row && cell.col < topLeftCell.col)) {
                        topLeftCell = cell;
                    }
                }
                
                const domCell = document.querySelector(`[data-row="${topLeftCell.row}"][data-col="${topLeftCell.col}"]`);
                const sumSpan = document.createElement('span');
                sumSpan.classList.add('cage-sum');
                sumSpan.textContent = cage.sum;
                domCell.appendChild(sumSpan);
            });
        }
        
        // Update the list of cages displayed in the sidebar
        function updateCagesList() {
            const container = document.getElementById('cages-container');
            
            if (cages.length === 0) {
                container.innerHTML = '<p class="text-gray-500 dark:text-gray-400 italic">No cages defined yet</p>';
                return;
            }
            
            container.innerHTML = '';
            
            cages.forEach((cage, index) => {
                const cageDiv = document.createElement('div');
                cageDiv.classList.add('flex', 'justify-between', 'items-center', 'mb-2', 'p-2', 'bg-white', 'dark:bg-dark-bg', 'rounded');
                
                // Format cell list for display
                const cellDisplay = cage.cells.map(cell => {
                    const [row, col] = cell.split(',').map(Number);
                    return `R${row+1}C${col+1}`;
                }).join(', ');
                
                cageDiv.innerHTML = `
                    <div>
                        <span class="font-medium">Cage ${index+1}:</span> 
                        <span>Sum = ${cage.sum}</span>
                    </div>
                    <button class="text-red-500 hover:text-red-700 transition-colors delete-cage" data-cage-id="${cage.id}">
                        ✕
                    </button>
                `;
                
                cageDiv.querySelector('.delete-cage').addEventListener('click', () => {
                    cages = cages.filter(c => c.id !== cage.id);
                    updateCageBorders();
                    updateCagesList();
                });
                
                // Add hover tooltip with cell list
                cageDiv.classList.add('tooltip-container', 'relative');
                const tooltip = document.createElement('div');
                tooltip.classList.add('tooltip');
                tooltip.textContent = cellDisplay;
                cageDiv.appendChild(tooltip);
                
                container.appendChild(cageDiv);
            });
        }
        
        // Update the internal grid data structure
        function updateGrid() {
            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    const input = document.querySelector(`[data-row="${row}"][data-col="${col}"] input`);
                    grid[row][col] = input.value ? parseInt(input.value) : 0;
                }
            }
        }
        
        // Reset the grid
        function resetGrid() {
            document.querySelectorAll('.sudoku-cell input').forEach(input => {
                input.value = '';
                input.disabled = false;
                input.classList.remove('text-green-600', 'dark:text-green-400');
            });
            
            grid = Array(9).fill().map(() => Array(9).fill(0));
            cages = [];
            updateCageBorders();
            updateCagesList();
            
            document.getElementById('solver-status').classList.add('hidden');
        }
        
        // Solve the Killer Sudoku puzzle
        async function solveKillerSudoku() {
            // Check if we have any cages defined
            if (cages.length === 0) {
                showToast("Please define at least one cage first");
                return;
            }
            
            // Show loading overlay
            document.getElementById('loading-overlay').classList.remove('hidden');
            
            // Make sure grid is updated with user input
            updateGrid();
            
            // Disable all inputs during solving
            document.querySelectorAll('.sudoku-cell input').forEach(input => {
                input.disabled = true;
            });
            
            try {
                // Create solver status element
                const statusEl = document.getElementById('solver-status');
                statusEl.innerHTML = 'Solving...';
                statusEl.classList.remove('hidden', 'bg-green-100', 'bg-red-100', 'dark:bg-green-900', 'dark:bg-red-900');
                statusEl.classList.add('bg-blue-100', 'dark:bg-blue-900');
                
                // Use setTimeout to allow UI to update before computationally intensive solving
                setTimeout(async () => {
                    const startTime = performance.now();
                    
                    // Call solve method
                    const result = await solve(grid, cages);
                    
                    // Hide loading overlay
                    document.getElementById('loading-overlay').classList.add('hidden');
                    
                    if (result.solved) {
                        // Update UI with solution
                        for (let row = 0; row < 9; row++) {
                            for (let col = 0; col < 9; col++) {
                                const input = document.querySelector(`[data-row="${row}"][data-col="${col}"] input`);
                                if (input.value === '') {
                                    input.value = result.grid[row][col];
                                    input.classList.add('text-green-600', 'dark:text-green-400');
                                }
                            }
                        }
                        
                        const solveTime = ((performance.now() - startTime) / 1000).toFixed(2);
                        statusEl.innerHTML = `✅ Solved in ${solveTime} seconds!`;
                        statusEl.classList.remove('bg-blue-100', 'dark:bg-blue-900');
                        statusEl.classList.add('bg-green-100', 'dark:bg-green-900');
                    } else {
                        statusEl.innerHTML = '❌ No solution found. Check your cage definitions.';
                        statusEl.classList.remove('bg-blue-100', 'dark:bg-blue-900');
                        statusEl.classList.add('bg-red-100', 'dark:bg-red-900');
                        
                        // Re-enable inputs
                        document.querySelectorAll('.sudoku-cell input').forEach(input => {
                            input.disabled = false;
                        });
                    }
                }, 100);
            } catch (error) {
                console.error('Solver error:', error);
                document.getElementById('loading-overlay').classList.add('hidden');
                
                const statusEl = document.getElementById('solver-status');
                statusEl.innerHTML = '❌ Error solving puzzle: ' + error.message;
                statusEl.classList.remove('bg-blue-100', 'dark:bg-blue-900');
                statusEl.classList.add('bg-red-100', 'dark:bg-red-900');
                statusEl.classList.remove('hidden');
                
                // Re-enable inputs
                document.querySelectorAll('.sudoku-cell input').forEach(input => {
                    input.disabled = false;
                });
            }
        }
        
        // The solving algorithm with backtracking
        async function solve(originalGrid, cages) {
            // Create a copy of the grid to work with
            const grid = originalGrid.map(row => [...row]);
            
            // Precompute cage membership for quick lookup
            const cellToCageMap = {};
            cages.forEach(cage => {
                cage.cells.forEach(cellStr => {
                    cellToCageMap[cellStr] = cage;
                });
            });
            
            // Check if the grid is valid so far
            function isValid(row, col, num) {
                // Check row and column
                for (let i = 0; i < 9; i++) {
                    if (grid[row][i] === num || grid[i][col] === num) {
                        return false;
                    }
                }
                
                // Check 3x3 box
                const boxRow = Math.floor(row / 3) * 3;
                const boxCol = Math.floor(col / 3) * 3;
                for (let i = 0; i < 3; i++) {
                    for (let j = 0; j < 3; j++) {
                        if (grid[boxRow + i][boxCol + j] === num) {
                            return false;
                        }
                    }
                }
                
                // Check cage constraints - sum and no repeats
                const cellKey = `${row},${col}`;
                const cage = cellToCageMap[cellKey];
                if (cage) {
                    // Create a temporary grid with the proposed number
                    const tempGrid = grid.map(row => [...row]);
                    tempGrid[row][col] = num;
                    
                    // Get all filled numbers in this cage
                    const filledCells = cage.cells.filter(cellStr => {
                        const [r, c] = cellStr.split(',').map(Number);
                        return tempGrid[r][c] !== 0;
                    });
                    
                    // Check sum if all cells are filled
                    if (filledCells.length === cage.cells.length) {
                        let sum = 0;
                        const used = new Set();
                        
                        for (const cellStr of cage.cells) {
                            const [r, c] = cellStr.split(',').map(Number);
                            sum += tempGrid[r][c];
                            
                            // Check for repeats within cage
                            if (used.has(tempGrid[r][c])) {
                                return false;
                            }
                            used.add(tempGrid[r][c]);
                        }
                        
                        if (sum !== cage.sum) {
                            return false;
                        }
                    } 
                    // If not all cells are filled, check if current sum exceeds target
                    else {
                        let currentSum = 0;
                        const used = new Set();
                        
                        for (const cellStr of filledCells) {
                            const [r, c] = cellStr.split(',').map(Number);
                            currentSum += tempGrid[r][c];
                            
                            // Check for repeats
                            if (used.has(tempGrid[r][c])) {
                                return false;
                            }
                            used.add(tempGrid[r][c]);
                        }
                        
                        // If current sum already exceeds target, invalid
                        if (currentSum > cage.sum) {
                            return false;
                        }
                        
                        // If remaining cells can't possibly sum to target, invalid
                        const remainingCells = cage.cells.length - filledCells.length;
                        // Minimum possible sum for remaining cells (using 1s)
                        const minPossibleSum = remainingCells;
                        if (currentSum + minPossibleSum > cage.sum) {
                            return false;
                        }
                    }
                }
                
                return true;
            }
            
            let steps = 0;
            const maxSteps = 1000000; // Prevent infinite loops
            
            // Find the cell with the fewest possible valid values
            function findBestCell() {
                let bestCell = null;
                let minOptions = 10; // More than possible (9)
                
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        if (grid[row][col] === 0) {
                            let validOptions = 0;
                            for (let num = 1; num <= 9; num++) {
                                if (isValid(row, col, num)) {
                                    validOptions++;
                                }
                            }
                            
                            if (validOptions < minOptions) {
                                minOptions = validOptions;
                                bestCell = { row, col, options: validOptions };
                                
                                // If we find a cell with no valid options, return immediately
                                if (validOptions === 0) {
                                    return bestCell;
                                }
                            }
                        }
                    }
                }
                
                return bestCell;
            }
            
            // Update loading status periodically
            let lastUpdateTime = performance.now();
            
            async function backtrack() {
                steps++;
                
                // Update status every 200ms
                const currentTime = performance.now();
                if (currentTime - lastUpdateTime > 200) {
                    lastUpdateTime = currentTime;
                    document.getElementById('loading-status').textContent = `Tried ${steps} combinations...`;
                    // Allow UI to update
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
                
                if (steps > maxSteps) {
                    throw new Error("Solving took too many steps. Please check your cage definitions.");
                }
                
                // Find an empty cell with fewest options
                const cell = findBestCell();
                
                // If no empty cell, puzzle is solved
                if (cell === null) {
                    return true;
                }
                
                // If a cell has no valid options, this path is invalid
                if (cell.options === 0) {
                    return false;
                }
                
                const { row, col } = cell;
                
                // Try each digit 1-9
                for (let num = 1; num <= 9; num++) {
                    if (isValid(row, col, num)) {
                        grid[row][col] = num;
                        
                        // Move to next cell recursively
                        if (await backtrack()) {
                            return true;
                        }
                        
                        // If not successful, backtrack
                        grid[row][col] = 0;
                    }
                }
                
                return false;
            }
            
            const result = await backtrack();
            
            return {
                solved: result,
                grid: grid,
                steps: steps
            };
        }
        
        // Show toast message
        function showToast(message) {
            // Create toast element if it doesn't exist
            let toast = document.getElementById('toast');
            if (!toast) {
                toast = document.createElement('div');
                toast.id = 'toast';
                toast.classList.add(
                    'fixed', 
                    'bottom-4', 
                    'left-1/2', 
                    'transform', 
                    '-translate-x-1/2',
                    'bg-black',
                    'bg-opacity-80',
                    'text-white',
                    'py-2',
                    'px-4',
                    'rounded-lg',
                    'shadow-lg',
                    'z-50',
                    'transition-opacity',
                    'duration-300',
                    'opacity-0'
                );
                document.body.appendChild(toast);
            }
            
            // Set message and show
            toast.textContent = message;
            toast.classList.remove('opacity-0');
            toast.classList.add('opacity-100');
            
            // Hide after 3 seconds
            setTimeout(() => {
                toast.classList.remove('opacity-100');
                toast.classList.add('opacity-0');
            }, 3000);
        }
        
        // Event listeners
        document.addEventListener('DOMContentLoaded', () => {
            initGrid();
            
            // Create cage button
            document.getElementById('btn-create-cage').addEventListener('click', () => {
                isCreatingCage = true;
                selectedCells = [];
                document.getElementById('btn-create-cage').classList.add('bg-secondary');
                document.getElementById('btn-create-cage').classList.remove('bg-primary');
                document.getElementById('btn-reset-cage').classList.remove('hidden');
                document.getElementById('selected-cells-count').textContent = '0';
                
                showToast('Select cells to create a cage');
            });
            
            // Reset cage creation
            document.getElementById('btn-reset-cage').addEventListener('click', () => {
                isCreatingCage = false;
                document.getElementById('btn-create-cage').classList.remove('bg-secondary');
                document.getElementById('btn-create-cage').classList.add('bg-primary');
                
                // Reset cell highlighting
                selectedCells.forEach(cellStr => {
                    const [row, col] = cellStr.split(',').map(Number);
                    highlightSelectedCell(row, col, false);
                });
                
                selectedCells = [];
                document.getElementById('cage-sum-modal').classList.add('hidden');
            });
            
            // Solve button
            document.getElementById('btn-solve').addEventListener('click', solveKillerSudoku);
            
            // Reset button
            document.getElementById('btn-reset').addEventListener('click', resetGrid);
            
            // Cage sum modal confirm button
            document.getElementById('btn-create-cage').addEventListener('dblclick', () => {
                if (selectedCells.length > 0) {
                    document.getElementById('cage-sum-modal').classList.remove('hidden');
                    document.getElementById('cage-sum-input').focus();
                } else {
                    showToast('Select cells for the cage first');
                }
            });
            
            // Cage sum modal cancel button
            document.getElementById('btn-cancel-cage').addEventListener('click', () => {
                document.getElementById('cage-sum-modal').classList.add('hidden');
            });
            
            // Cage sum modal confirm button
            document.getElementById('btn-confirm-cage').addEventListener('click', () => {
                const sumInput = document.getElementById('cage-sum-input');
                const sum = parseInt(sumInput.value);
                
                if (!sum || sum <= 0) {
                    showToast('Please enter a valid sum');
                    return;
                }
                
                createCage(sum);
                
                // Reset cage creation mode
                isCreatingCage = false;
                document.getElementById('btn-create-cage').classList.remove('bg-secondary');
                document.getElementById('btn-create-cage').classList.add('bg-primary');
                sumInput.value = '';
            });
            
            // When user has selected cells, show modal on double-click on a selected cell
            document.addEventListener('dblclick', (e) => {
                if (!isCreatingCage || selectedCells.length === 0) return;
                
                const cellDiv = e.target.closest('.sudoku-cell');
                if (!cellDiv) return;
                
                const row = parseInt(cellDiv.dataset.row);
                const col = parseInt(cellDiv.dataset.col);
                const cellKey = `${row},${col}`;
                
                if (selectedCells.includes(cellKey)) {
                    document.getElementById('cage-sum-modal').classList.remove('hidden');
                    document.getElementById('cage-sum-input').focus();
                }
            });
        });
    </script>
</body>
</html>